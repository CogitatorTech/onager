{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Onager","text":"<p>Onager is a DuckDB extension that adds a large number of graph analytics functions to DuckDB, including centrality measures, community detection algorithms, pathfinding algorithms, graph metrics, and graph generators. Onager is written in Rust and uses Graphina graph library under the hood.</p> <p>Compared to DuckPGQ, Onager is focused on graph analytics instead of graph querying. More specifically, DuckPGQ implements SQL/PGQ (the SQL:2023 standard) for graph pattern matching and path-finding queries with a property graph model. Onager instead provides a collection of ready-to-use graph algorithms (like PageRank, Louvain community detection, Dijkstra's shortest path, etc.) as simple table functions. Users typically want something like DuckPGQ when they need to query graph patterns, and use Onager when they need to run graph algorithms on their graph data.</p>"},{"location":"#install","title":"Install","text":"<pre><code>install onager from community;\nload onager;\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>-- Create edge data\ncreate table edges as\nselect *\nfrom (values (1::bigint, 2::bigint),\n             (2, 3),\n             (3, 1),\n             (3, 4)) t(src, dst);\n\n-- Compute PageRank\nselect node_id, round(rank, 4) as rank\nfrom onager_ctr_pagerank((select src, dst from edges))\norder by rank desc;\n\n-- Detect communities\nselect node_id, community\nfrom onager_cmm_louvain((select src, dst from edges));\n\n-- Find shortest paths\nselect node_id, distance\nfrom onager_pth_dijkstra((select src, dst from edges), source := 1);\n</code></pre>"},{"location":"#algorithms","title":"Algorithms","text":"<p>Onager currently includes the following graph algorithms:</p> Category Algorithms Centrality PageRank, degree, betweenness, closeness, eigenvector, Katz, harmonic, VoteRank, local reaching, and Laplacian Community Louvain, connected components, label propagation, Girvan-Newman, spectral, and Infomap Paths Dijkstra, Bellman-Ford, Floyd-Warshall, BFS, and DFS Metrics diameter, radius, clustering, transitivity, triangles, assortativity, density, and average path length Link Prediction Jaccard, Adamic-Adar, preferential attachment, resource allocation, and common neighbors Subgraphs ego graph, k-hop neighbors, and induced subgraph Generators Erd\u0151s-R\u00e9nyi, Barab\u00e1si-Albert, and Watts-Strogatz Approximation max clique, independent set, vertex cover, and TSP"},{"location":"#get-started","title":"Get Started","text":"<ul> <li>Quick Start</li> <li>SQL Function Reference</li> </ul>"},{"location":"examples/analytics/","title":"Graph Analytics Examples","text":""},{"location":"examples/analytics/#social-network-analysis","title":"Social Network Analysis","text":""},{"location":"examples/analytics/#finding-influencers","title":"Finding Influencers","text":"<p>Use PageRank and degree centrality to identify influential users:</p> <pre><code>-- Create social network edges\ncreate table follows as select * from (values\n  (1, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 1), (2, 4), (3, 5)\n) t(follower, followed);\n\n-- Find top influencers by PageRank\nselect node_id as user_id, rank\nfrom onager_ctr_pagerank((select follower as src, followed as dst from follows))\norder by rank desc\nlimit 5;\n\n-- Combine multiple centrality metrics\nwith centralities as (\n  select p.node_id, p.rank as pagerank, d.in_degree\n  from onager_ctr_pagerank((select follower as src, followed as dst from follows)) p\n  join onager_ctr_degree((select follower as src, followed as dst from follows)) d\n    on p.node_id = d.node_id\n)\nselect *, (pagerank + in_degree/10) as combined_score\nfrom centralities\norder by combined_score desc;\n</code></pre>"},{"location":"examples/analytics/#community-detection","title":"Community Detection","text":"<p>Find groups of tightly-connected users:</p> <pre><code>-- Detect communities with Louvain\nselect node_id as user_id, community\nfrom onager_cmm_louvain((select follower as src, followed as dst from follows));\n\n-- Count users per community\nselect community, count(*) as size\nfrom onager_cmm_louvain((select follower as src, followed as dst from follows))\ngroup by community\norder by size desc;\n</code></pre>"},{"location":"examples/analytics/#fraud-detection","title":"Fraud Detection","text":""},{"location":"examples/analytics/#ring-detection-with-clustering","title":"Ring Detection with Clustering","text":"<p>High local clustering may indicate coordinated behavior:</p> <pre><code>create table transactions as select * from (values\n  (100, 200), (200, 300), (300, 100), -- Triangle (suspicious)\n  (400, 500), (500, 600)               -- Normal chain\n) t(sender, receiver);\n\n-- Find nodes with high clustering (potential fraud rings)\nselect node_id as account, coefficient\nfrom onager_par_clustering((select sender as src, receiver as dst from transactions))\nwhere coefficient &gt; 0.5;\n\n-- Count triangles per account\nselect node_id as account, triangles\nfrom onager_par_triangles((select sender as src, receiver as dst from transactions))\nwhere triangles &gt; 0;\n</code></pre>"},{"location":"examples/analytics/#recommendation-systems","title":"Recommendation Systems","text":""},{"location":"examples/analytics/#personalized-pagerank-for-recommendations","title":"Personalized PageRank for Recommendations","text":"<pre><code>-- User interaction graph\ncreate table interactions as select * from (values\n  (1, 10), (1, 20), (2, 10), (2, 30), (3, 20), (3, 30)\n) t(user_id, item_id);\n\n-- Create edges (user-item bipartite graph)\ncreate table edges as\n  select user_id as src, item_id + 1000 as dst from interactions;\n\n-- Recommend items for user 1 based on their interactions\n-- Using ego graph to explore local neighborhood\nselect *\nfrom onager_sub_k_hop_neighbors(edges, start := 1, k := 2)\nwhere node_id &gt; 1000;  -- Filter to items only\n</code></pre>"},{"location":"examples/analytics/#network-health-metrics","title":"Network Health Metrics","text":""},{"location":"examples/analytics/#detailed-network-summary","title":"Detailed Network Summary","text":"<pre><code>-- Get network health metrics\nselect 'Diameter' as metric, diameter as value\nfrom onager_mtr_diameter((select src, dst from edges))\nunion all\nselect 'Radius', radius\nfrom onager_mtr_radius((select src, dst from edges))\nunion all\nselect 'Avg Clustering', avg_clustering\nfrom onager_mtr_avg_clustering((select src, dst from edges))\nunion all\nselect 'Transitivity', transitivity\nfrom onager_mtr_transitivity((select src, dst from edges))\nunion all\nselect 'Assortativity', assortativity\nfrom onager_mtr_assortativity((select src, dst from edges));\n</code></pre>"},{"location":"examples/basic/","title":"Basic Usage","text":"<p>This example shows basic graph analytics workflows using the Onager.</p>"},{"location":"examples/basic/#setup","title":"Setup","text":"<pre><code>-- Create a sample social network\ncreate table social_edges as\nselect *\nfrom (values (1::bigint, 2::bigint),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 4),\n             (3, 5),\n             (4, 5),\n             (5, 6)) t(user_from, user_to);\n</code></pre>"},{"location":"examples/basic/#find-key-influencers","title":"Find Key Influencers","text":"<pre><code>select *\nfrom onager_ctr_pagerank((select user_from, user_to from social_edges))\norder by rank desc;\n</code></pre>"},{"location":"examples/basic/#detect-communities","title":"Detect Communities","text":"<pre><code>select *\nfrom onager_cmm_louvain((select user_from, user_to from social_edges));\n</code></pre>"},{"location":"examples/basic/#check-network-connectivity","title":"Check Network Connectivity","text":"<pre><code>-- How many connected components?\nselect count(distinct component) as num_components\nfrom onager_cmm_components((select user_from, user_to from social_edges));\n</code></pre>"},{"location":"examples/basic/#measure-network-structure","title":"Measure Network Structure","text":"<pre><code>select diameter,\n       (select avg_clustering\n        from onager_mtr_avg_clustering((select user_from, user_to from social_edges))) as clustering\nfrom onager_mtr_diameter((select user_from, user_to from social_edges));\n</code></pre>"},{"location":"examples/basic/#generate-test-data","title":"Generate Test Data","text":"<pre><code>-- Create a larger random network for testing\ncreate table test_network as\nselect *\nfrom onager_gen_erdos_renyi(500, 0.02, seed := 42);\n\n-- Analyze it\nselect count(*) as edge_count\nfrom test_network;\n</code></pre>"},{"location":"examples/centrality/","title":"Centrality Analysis Example","text":""},{"location":"examples/centrality/#finding-influential-nodes-in-a-network","title":"Finding Influential Nodes in a Network","text":"<pre><code>-- Create a citation network\ncreate table citations as select * from (values\n  (1::bigint, 2::bigint), (1, 3), (2, 4), (2, 5),\n  (3, 4), (3, 6), (4, 7), (5, 7),\n  (6, 7), (7, 8), (7, 9), (8, 10), (9, 10)\n) t(paper_from, paper_to);\n\n-- PageRank: overall importance\nselect * from onager_ctr_pagerank((select paper_from, paper_to from citations))\norder by rank desc limit 5;\n\n-- Betweenness: information brokers\nselect * from onager_ctr_betweenness((select paper_from, paper_to from citations))\norder by betweenness desc limit 5;\n\n-- Degree: most connected\nselect * from onager_ctr_degree((select paper_from, paper_to from citations))\norder by in_degree + out_degree desc limit 5;\n</code></pre>"},{"location":"examples/centrality/#comparing-centrality-measures","title":"Comparing Centrality Measures","text":"<pre><code>with\n  pr as (select node_id, rank from onager_ctr_pagerank((select paper_from, paper_to from citations))),\n  bt as (select node_id, betweenness from onager_ctr_betweenness((select paper_from, paper_to from citations))),\n  dg as (select node_id, in_degree + out_degree as total_degree from onager_ctr_degree((select paper_from, paper_to from citations)))\nselect pr.node_id, pr.rank, bt.betweenness, dg.total_degree\nfrom pr\njoin bt on pr.node_id = bt.node_id\njoin dg on pr.node_id = dg.node_id\norder by pr.rank desc;\n</code></pre>"},{"location":"examples/community/","title":"Community Detection Example","text":""},{"location":"examples/community/#segmenting-users","title":"Segmenting Users","text":"<pre><code>-- Social connections\ncreate table friendships as select * from (values\n  -- Group 1: Tight-knit friends\n  (1::bigint, 2::bigint), (1, 3), (2, 3),\n  -- Group 2: Work colleagues  \n  (4::bigint, 5::bigint), (4, 6), (5, 6), (5, 7), (6, 7),\n  -- Bridge between groups\n  (3, 4)\n) t(user1, user2);\n\n-- Detect communities\nselect * from onager_cmm_louvain((select user1, user2 from friendships))\norder by community, node_id;\n</code></pre>"},{"location":"examples/community/#analyzing-community-structure","title":"Analyzing Community Structure","text":"<pre><code>with communities as (\n  select * from onager_cmm_louvain((select user1, user2 from friendships))\n)\nselect\n  community,\n  count(*) as members,\n  array_agg(node_id order by node_id) as member_list\nfrom communities\ngroup by community\norder by members desc;\n</code></pre>"},{"location":"examples/community/#label-propagation-faster-alternative","title":"Label Propagation (Faster Alternative)","text":"<pre><code>select * from onager_cmm_label_prop((select user1, user2 from friendships));\n</code></pre>"},{"location":"examples/links/","title":"Link Prediction Example","text":""},{"location":"examples/links/#friend-recommendations","title":"Friend Recommendations","text":"<pre><code>-- Current friendships\ncreate table current_friends as select * from (values\n  (1::bigint, 2::bigint), (1, 3), (2, 3), (2, 4),\n  (3, 5), (4, 5), (4, 6), (5, 6)\n) t(user1, user2);\n\n-- Predict new friendships using Adamic-Adar\nselect node1, node2, score\nfrom onager_lnk_adamic_adar((select user1, user2 from current_friends))\nwhere score &gt; 0\norder by score desc\nlimit 10;\n</code></pre>"},{"location":"examples/links/#comparing-prediction-methods","title":"Comparing Prediction Methods","text":"<pre><code>with\n  aa as (select node1, node2, score as adamic_adar from onager_lnk_adamic_adar((select user1, user2 from current_friends))),\n  jc as (select node1, node2, jaccard from onager_lnk_jaccard((select user1, user2 from current_friends))),\n  pa as (select node1, node2, score as pref_attach from onager_lnk_pref_attach((select user1, user2 from current_friends)))\nselect aa.node1, aa.node2, aa.adamic_adar, jc.jaccard, pa.pref_attach\nfrom aa\njoin jc on aa.node1 = jc.node1 and aa.node2 = jc.node2\njoin pa on aa.node1 = pa.node1 and aa.node2 = pa.node2\norder by aa.adamic_adar desc\nlimit 10;\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide walks you through your first graph analysis with Onager.</p>"},{"location":"getting-started/quickstart/#1-install-and-load","title":"1. Install and Load","text":"<p>Onager is available in the DuckDB community extensions repository and can be installed with the following commands:</p> <pre><code>install onager from community;\nload onager;\n</code></pre>"},{"location":"getting-started/quickstart/#2-create-some-edge-data","title":"2. Create Some Edge Data","text":"<p>Onager works with edge tables \u2014 any table with source and destination columns:</p> <pre><code>create table edges as\nselect *\nfrom (values (1::bigint, 2::bigint),\n             (2, 3),\n             (3, 1),\n             (3, 4),\n             (4, 5),\n             (5, 6)) t(src, dst);\n</code></pre>"},{"location":"getting-started/quickstart/#3-find-important-nodes","title":"3. Find Important Nodes","text":"<p>Use PageRank to identify the most important nodes:</p> <pre><code>select node_id, round(rank, 4) as importance\nfrom onager_ctr_pagerank((select src, dst from edges))\norder by rank desc;\n</code></pre>"},{"location":"getting-started/quickstart/#4-detect-communities","title":"4. Detect Communities","text":"<p>Find clusters of connected nodes:</p> <pre><code>select node_id, community\nfrom onager_cmm_louvain((select src, dst from edges))\norder by community, node_id;\n</code></pre>"},{"location":"getting-started/quickstart/#5-explore-graph-structure","title":"5. Explore Graph Structure","text":"<p>Measure network properties:</p> <pre><code>-- How many hops across the network?\nselect diameter\nfrom onager_mtr_diameter((select src, dst from edges));\n\n-- How clustered is it?\nselect round(avg_clustering, 4) as clustering\nfrom onager_mtr_avg_clustering((select src, dst from edges));\n</code></pre>"},{"location":"getting-started/quickstart/#6-find-shortest-paths","title":"6. Find Shortest Paths","text":"<p>Calculate distances from a starting node:</p> <pre><code>select node_id, distance\nfrom onager_pth_dijkstra((select src, dst from edges), source := 1)\norder by distance;\n</code></pre>"},{"location":"getting-started/quickstart/#working-with-real-data","title":"Working with Real Data","text":"<p>Import your edge data from any source DuckDB supports:</p> <pre><code>-- From a CSV file\ncreate table my_edges as\nselect *\nfrom read_csv('edges.csv');\n\n-- From a Parquet file\ncreate table my_edges as\nselect *\nfrom read_parquet('edges.parquet');\n\n-- Run PageRank on your data\nselect *\nfrom onager_ctr_pagerank((select source_id as src, target_id as dst\n                          from my_edges));\n</code></pre>"},{"location":"getting-started/quickstart/#input-format","title":"Input Format","text":"<p>All functions expect edges as a subquery with two <code>bigint</code> columns:</p> <pre><code>select *\nfrom onager_function_name((select source_column as src, target_column as dst\n                           from your_table));\n</code></pre> <p>See the Input Formats reference for details on node IDs, weighted functions, and directed graphs.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Centrality Algorithms \u2014 Find important nodes</li> <li>Community Detection \u2014 Discover clusters</li> <li>Graph Metrics \u2014 Measure network properties</li> <li>SQL Function Reference \u2014 All functions</li> </ul>"},{"location":"guide/approximation/","title":"Approximation Algorithms","text":"<p>These algorithms provide fast approximations for NP-hard graph problems.</p>"},{"location":"guide/approximation/#setup","title":"Setup","text":"<pre><code>create table edges as select * from (values\n  (1::bigint, 2::bigint), (1, 3), (2, 3), (2, 4),\n  (3, 4), (3, 5), (4, 5), (5, 6)\n) t(src, dst);\n</code></pre>"},{"location":"guide/approximation/#maximum-clique","title":"Maximum Clique","text":"<p>Finds an approximate maximum clique (largest fully connected subgraph).</p> <pre><code>select node_id\nfrom onager_apx_max_clique((select src, dst from edges));\n</code></pre> Column Type Description node_id bigint Node in the clique"},{"location":"guide/approximation/#maximum-independent-set","title":"Maximum Independent Set","text":"<p>Finds an approximate maximum independent set (largest set of non-adjacent nodes).</p> <pre><code>select node_id\nfrom onager_apx_independent_set((select src, dst from edges));\n</code></pre> Column Type Description node_id bigint Node in the independent set"},{"location":"guide/approximation/#minimum-vertex-cover","title":"Minimum Vertex Cover","text":"<p>Finds an approximate minimum vertex cover (smallest set of nodes that covers all edges).</p> <pre><code>select node_id\nfrom onager_apx_vertex_cover((select src, dst from edges));\n</code></pre> Column Type Description node_id bigint Node in the vertex cover"},{"location":"guide/approximation/#traveling-salesman-problem-tsp","title":"Traveling Salesman Problem (TSP)","text":"<p>Finds an approximate TSP tour using a greedy algorithm. Requires weighted edges.</p> <pre><code>-- Create weighted edges\ncreate table weighted_edges as select * from (values\n  (1::bigint, 2::bigint, 1.0::double),\n  (2, 3, 2.0), (3, 4, 1.5), (4, 1, 2.5)\n) t(src, dst, weight);\n\nselect order_idx, node_id\nfrom onager_apx_tsp((select src, dst, weight from weighted_edges))\norder by order_idx;\n</code></pre> Column Type Description order_idx bigint Position in the tour node_id bigint Node at this position"},{"location":"guide/centrality/","title":"Centrality Algorithms","text":"<p>Centrality measures identify the most important nodes (or vertices) in a graph. The importance of a node depends on the context and measured differently by each algorithm.</p>"},{"location":"guide/centrality/#setup","title":"Setup","text":"<p>All examples use this sample social network:</p> <pre><code>create table edges as select * from (values\n  (1::bigint, 2::bigint), (1, 3), (2, 3), (2, 4),\n  (3, 4), (3, 5), (4, 5), (5, 6), (6, 7), (7, 8)\n) t(src, dst);\n</code></pre>"},{"location":"guide/centrality/#pagerank","title":"PageRank","text":"<p>PageRank measures importance based on the link structure. A node is important if many important nodes point to it. It was originally developed by Google for ranking web pages.</p> \\[ PR(u) = \\frac{1-d}{N} + d \\sum_{v \\in B_u} \\frac{PR(v)}{L(v)} \\] <p>where \\(d\\) is the damping factor, \\(N\\) is the number of nodes, \\(B_u\\) is the set of nodes linking to \\(u\\), and \\(L(v)\\) is the out-degree of \\(v\\).</p> <pre><code>select node_id, round(rank, 4) as rank\nfrom onager_ctr_pagerank((select src, dst from edges))\norder by rank desc;\n</code></pre> Column Type Description node_id bigint Node identifier rank double PageRank score (higher = more important) <p>Optional parameters:</p> <ul> <li><code>damping</code> (default 0.85): Probability of following a link vs jumping randomly</li> <li><code>iterations</code> (default 100): Maximum iterations</li> <li><code>directed</code> (default false): Treat graph as directed</li> </ul> <pre><code>-- Custom damping factor\nselect * from onager_ctr_pagerank(\n  (select src, dst from edges),\n  damping := 0.9,\n  iterations := 50\n);\n</code></pre>"},{"location":"guide/centrality/#degree-centrality","title":"Degree Centrality","text":"<p>The simplest centrality measure \u2014 counts the number of connections per node. High degree nodes are \"hubs\" with many direct connections.</p> \\[ C_D(v) = \\frac{\\deg(v)}{N-1} \\] <pre><code>select node_id, in_degree, out_degree, (in_degree + out_degree) as total\nfrom onager_ctr_degree((select src, dst from edges))\norder by total desc;\n</code></pre> Column Type Description node_id bigint Node identifier in_degree double Number of incoming edges out_degree double Number of outgoing edges"},{"location":"guide/centrality/#betweenness-centrality","title":"Betweenness Centrality","text":"<p>Measures how often a node appears on shortest paths between other nodes. High betweenness nodes act as bridges or bottlenecks controlling information flow.</p> \\[ C_B(v) = \\sum_{s \\neq v \\neq t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}} \\] <p>where \\(\\sigma_{st}\\) is the number of shortest paths from \\(s\\) to \\(t\\), and \\(\\sigma_{st}(v)\\) is the number passing through \\(v\\).</p> <p>Performance</p> <p>This algorithm has O(n\u00b7m) complexity. So, it may be slow on dense graphs with more than 10,000 nodes.</p> <pre><code>select node_id, round(betweenness, 4) as betweenness\nfrom onager_ctr_betweenness((select src, dst from edges))\nwhere betweenness &gt; 0\norder by betweenness desc;\n</code></pre> Column Type Description node_id bigint Node identifier betweenness double Betweenness centrality score"},{"location":"guide/centrality/#closeness-centrality","title":"Closeness Centrality","text":"<p>Measures how close a node is to all other nodes (average shortest path distance). High closeness means information can spread quickly from this node.</p> \\[ C_C(v) = \\frac{N-1}{\\sum_{u \\neq v} d(u, v)} \\] <p>where \\(d(u, v)\\) is the shortest path distance between \\(u\\) and \\(v\\).</p> <pre><code>select node_id, round(closeness, 4) as closeness\nfrom onager_ctr_closeness((select src, dst from edges))\norder by closeness desc;\n</code></pre> Column Type Description node_id bigint Node identifier closeness double Inverse of average distance to others"},{"location":"guide/centrality/#harmonic-centrality","title":"Harmonic Centrality","text":"<p>A variant of closeness that handles disconnected graphs. Uses the sum of inverse distances instead of inverse of sum.</p> \\[ C_H(v) = \\sum_{u \\neq v} \\frac{1}{d(u, v)} \\] <pre><code>select node_id, round(harmonic, 4) as harmonic\nfrom onager_ctr_harmonic((select src, dst from edges))\norder by harmonic desc;\n</code></pre>"},{"location":"guide/centrality/#eigenvector-centrality","title":"Eigenvector Centrality","text":"<p>A node is important if connected to other important nodes. This creates a recursive definition where connections to high-scoring nodes contribute more.</p> <p>Performance</p> <p>This algorithm uses power iteration on the adjacency matrix. May be slow on graphs with more than 10,000 nodes.</p> <pre><code>select node_id, round(eigenvector, 4) as eigenvector\nfrom onager_ctr_eigenvector((select src, dst from edges))\norder by eigenvector desc;\n</code></pre> <p>Optional parameters:</p> <ul> <li><code>max_iter</code> (default 100): Maximum iterations</li> <li><code>tolerance</code> (default 1e-6): Convergence threshold</li> </ul>"},{"location":"guide/centrality/#katz-centrality","title":"Katz Centrality","text":"<p>Similar to eigenvector centrality but counts all paths, not just direct connections. Longer paths contribute less based on an attenuation factor.</p> <pre><code>select node_id, round(katz, 4) as katz\nfrom onager_ctr_katz((select src, dst from edges), alpha := 0.1)\norder by katz desc;\n</code></pre> <p>Optional parameters:</p> <ul> <li><code>alpha</code> (default 0.1): Attenuation factor for longer paths</li> <li><code>beta</code> (default 1.0): Weight for initial centrality</li> </ul>"},{"location":"guide/centrality/#voterank","title":"VoteRank","text":"<p>VoteRank identifies influential spreaders in a network. It iteratively selects nodes that can best spread information, penalizing neighbors of already-selected nodes to ensure diversity.</p> <pre><code>select node_id\nfrom onager_ctr_voterank((select src, dst from edges), num_seeds := 5)\norder by node_id;\n</code></pre> Column Type Description node_id bigint Influential spreader node ID <p>Optional parameters:</p> <ul> <li><code>num_seeds</code> (default 10): Number of influential nodes to return</li> </ul>"},{"location":"guide/centrality/#local-reaching-centrality","title":"Local Reaching Centrality","text":"<p>Measures how many nodes can be reached within a specified distance. Higher values indicate nodes that can quickly spread information.</p> <pre><code>select node_id, round(centrality, 2) as reach\nfrom onager_ctr_local_reaching((select src, dst from edges), distance := 2)\norder by centrality desc;\n</code></pre> Column Type Description node_id bigint Node identifier centrality double Number of reachable nodes <p>Optional parameters:</p> <ul> <li><code>distance</code> (default 2): Maximum distance to consider</li> </ul>"},{"location":"guide/centrality/#laplacian-centrality","title":"Laplacian Centrality","text":"<p>Based on the Laplacian matrix of the graph. Captures both node degree and neighbor connectivity.</p> <pre><code>select node_id, round(centrality, 2) as laplacian\nfrom onager_ctr_laplacian((select src, dst from edges))\norder by centrality desc;\n</code></pre> Column Type Description node_id bigint Node identifier centrality double Laplacian centrality"},{"location":"guide/centrality/#complete-example-influencer-analysis","title":"Complete Example: Influencer Analysis","text":"<p>Find the top influencers using multiple centrality metrics:</p> <pre><code>-- Create a social network\ncreate table follows as select * from (values\n  (1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 5),\n  (4, 5), (4, 6), (5, 6), (5, 7), (6, 7), (6, 8),\n  (7, 8), (7, 9), (8, 9), (8, 10), (9, 10)\n) t(follower, followed);\n\n-- Combine multiple centrality measures\nwith pr as (\n  select node_id, rank from onager_ctr_pagerank(\n    (select follower as src, followed as dst from follows)\n  )\n),\ndeg as (\n  select node_id, in_degree from onager_ctr_degree(\n    (select follower as src, followed as dst from follows)\n  )\n),\nbet as (\n  select node_id, betweenness from onager_ctr_betweenness(\n    (select follower as src, followed as dst from follows)\n  )\n)\nselect\n  pr.node_id as user_id,\n  round(pr.rank, 4) as pagerank,\n  deg.in_degree as followers,\n  round(bet.betweenness, 2) as bridge_score\nfrom pr\njoin deg on pr.node_id = deg.node_id\njoin bet on pr.node_id = bet.node_id\norder by pr.rank desc\nlimit 5;\n</code></pre>"},{"location":"guide/community/","title":"Community Detection","text":"<p>Community detection algorithms identify clusters of nodes that are more densely connected to each other than to the rest of the graph. These groups often represent meaningful structures like social circles, functional modules, or topic clusters.</p>"},{"location":"guide/community/#setup","title":"Setup","text":"<p>All examples use this sample network with two natural communities:</p> <pre><code>create table edges as\nselect *\nfrom (values\n          -- Community 1 (nodes 1-4)\n          (1::bigint, 2::bigint),\n          (1, 3),\n          (2, 3),\n          (2, 4),\n          (3, 4),\n          -- Community 2 (nodes 5-8)\n          (5, 6),\n          (5, 7),\n          (6, 7),\n          (6, 8),\n          (7, 8),\n          -- Bridge between communities\n          (4, 5)) t(src, dst);\n</code></pre>"},{"location":"guide/community/#louvain-algorithm","title":"Louvain Algorithm","text":"<p>The Louvain algorithm is a greedy optimization method that maximizes modularity. It works hierarchically, first finding small communities, then aggregating them into larger ones. Fast and produces high-quality results on most networks.</p> \\[ Q = \\frac{1}{2m} \\sum_{ij} \\left[ A_{ij} - \\frac{k_i k_j}{2m} \\right] \\delta(c_i, c_j) \\] <p>where \\(A_{ij}\\) is the adjacency matrix, \\(k_i\\) is the degree of node \\(i\\), \\(m\\) is the total edges, and \\(\\delta(c_i, c_j)\\) is 1 if nodes \\(i\\) and \\(j\\) are in the same community.</p> <pre><code>select node_id, community\nfrom onager_cmm_louvain((select src, dst from edges))\norder by community, node_id;\n</code></pre> Column Type Description node_id bigint Node identifier community bigint Community ID this node belongs to <p>Use the <code>seed</code> parameter for reproducible results:</p> <pre><code>select *\nfrom onager_cmm_louvain((select src, dst from edges), seed := 42);\n</code></pre>"},{"location":"guide/community/#connected-components","title":"Connected Components","text":"<p>Finds groups of nodes where every node is reachable from every other node in the group. Unlike community detection, this is a topological property - nodes are in the same component if any path connects them.</p> <pre><code>select node_id, component\nfrom onager_cmm_components((select src, dst from edges))\norder by component, node_id;\n</code></pre> Column Type Description node_id bigint Node identifier component bigint Component ID (connected subgraph)"},{"location":"guide/community/#label-propagation","title":"Label Propagation","text":"<p>A fast, near-linear time algorithm. Each node adopts the most common label among its neighbors. Simple but can produce different results on each run.</p> <pre><code>select node_id, label\nfrom onager_cmm_label_prop((select src, dst from edges))\norder by label, node_id;\n</code></pre> Column Type Description node_id bigint Node identifier label bigint Community label"},{"location":"guide/community/#girvan-newman","title":"Girvan-Newman","text":"<p>Detects communities by progressively removing edges with highest betweenness. Produces a hierarchy of communities. Specify the desired number of communities.</p> <p>Performance</p> <p>This algorithm has O(m\u00b2\u00b7n) complexity. So, it's recommended to use it only on smaller graphs (like with fewer than 500 nodes).</p> <pre><code>select node_id, community\nfrom onager_cmm_girvan_newman((select src, dst from edges), communities := 2)\norder by community, node_id;\n</code></pre>"},{"location":"guide/community/#spectral-clustering","title":"Spectral Clustering","text":"<p>Uses eigenvalues of the graph Laplacian to partition nodes. Works well when communities have similar sizes.</p> <p>Performance</p> <p>This algorithm requires eigendecomposition with O(n\u00b3) complexity. Use only on graphs with fewer than 5,000 nodes.</p> <pre><code>select node_id, cluster\nfrom onager_cmm_spectral((select src, dst from edges), k := 2)\norder by cluster, node_id;\n</code></pre>"},{"location":"guide/community/#infomap","title":"Infomap","text":"<p>Optimizes the map equation to find communities that minimize the description length of a random walk. Particularly good at finding flow-based communities.</p> <pre><code>select node_id, community\nfrom onager_cmm_infomap((select src, dst from edges))\norder by community, node_id;\n</code></pre>"},{"location":"guide/community/#complete-example-community-analysis","title":"Complete Example: Community Analysis","text":"<p>Analyze community structure and find bridge nodes:</p> <pre><code>-- Create a network\ncreate table social as\nselect *\nfrom (values (1, 2),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 4),\n             (4, 5),\n             (5, 6),\n             (5, 7),\n             (6, 7),\n             (6, 8),\n             (7, 8),\n             (8, 9),\n             (9, 10),\n             (9, 11),\n             (10, 11),\n             (10, 12),\n             (11, 12)) t(src, dst);\n\n-- Detect communities\nwith comms as (select node_id, community\n               from onager_cmm_louvain((select src, dst from social), seed := 42))\nselect community, count(*) as size, array_agg(node_id order by node_id) as members\nfrom comms\ngroup by community\norder by size desc;\n\n-- Find bridge nodes (high betweenness between communities)\nselect c.node_id, c.community, round(b.betweenness, 2) as bridge_score\nfrom onager_cmm_louvain((select src, dst from social), seed := 42) c\n         join onager_ctr_betweenness((select src, dst from social)) b\n              on c.node_id = b.node_id\nwhere b.betweenness &gt; 0\norder by b.betweenness desc limit 5;\n</code></pre>"},{"location":"guide/generators/","title":"Graph Generators","text":"<p>Graph generators create synthetic networks with specific structural properties. Useful for testing algorithms, simulating networks, or creating benchmark datasets.</p>"},{"location":"guide/generators/#erdos-renyi-random-graphs","title":"Erd\u0151s-R\u00e9nyi Random Graphs","text":"<p>Creates a random graph where each possible edge exists with probability p. This is the simplest random graph model, useful as a null model or for testing.</p> <p>Parameters:</p> <ul> <li><code>n</code>: Number of nodes</li> <li><code>p</code>: Edge probability (0 to 1)</li> <li><code>seed</code>: Optional random seed for reproducibility</li> </ul> <pre><code>-- Create a random graph with 100 nodes, 10% edge probability\nselect src, dst\nfrom onager_gen_erdos_renyi(100, 0.1, seed := 42);\n</code></pre> Column Type Description src bigint Source node (0 to n-1) dst bigint Destination node <p>The expected number of edges is approximately n\u00d7(n-1)\u00d7p/2 for undirected graphs.</p> <pre><code>-- Count edges in different random graphs\nselect (select count(*) from onager_gen_erdos_renyi(50, 0.1, seed := 1)) as sparse,\n       (select count(*) from onager_gen_erdos_renyi(50, 0.3, seed := 1)) as medium,\n       (select count(*) from onager_gen_erdos_renyi(50, 0.5, seed := 1)) as dense;\n</code></pre>"},{"location":"guide/generators/#barabasi-albert-scale-free-graphs","title":"Barab\u00e1si-Albert Scale-Free Graphs","text":"<p>Creates a network with a power-law degree distribution (\"scale-free\"). New nodes attach preferentially to existing high-degree nodes. Models many real networks like the web, social networks, and citation networks.</p> <p>Parameters:</p> <ul> <li><code>n</code>: Number of nodes</li> <li><code>m</code>: Number of edges each new node creates</li> <li><code>seed</code>: Optional random seed</li> </ul> <pre><code>-- Create a scale-free network with 100 nodes\nselect src, dst\nfrom onager_gen_barabasi_albert(100, 2, seed := 42);\n</code></pre> <p>The resulting graph will have hub nodes with many connections and many nodes with few connections:</p> <pre><code>-- Verify power-law degree distribution\nwith edges as (select src, dst\n               from onager_gen_barabasi_albert(500, 2, seed := 42)),\n     degrees as (select node_id, in_degree + out_degree as degree\n                 from onager_ctr_degree((select src, dst from edges)))\nselect degree, count(*) as num_nodes\nfrom degrees\ngroup by degree\norder by degree;\n</code></pre>"},{"location":"guide/generators/#watts-strogatz-small-world-graphs","title":"Watts-Strogatz Small-World Graphs","text":"<p>Creates a network with high clustering and short average path length (\"small-world\"). Starts with a ring lattice and randomly rewires edges. Models networks where nodes cluster locally but shortcuts exist.</p> <p>Parameters:</p> <ul> <li><code>n</code>: Number of nodes</li> <li><code>k</code>: Number of nearest neighbors in the ring</li> <li><code>beta</code>: Rewiring probability (0 = regular lattice, 1 = random)</li> <li><code>seed</code>: Optional random seed</li> </ul> <pre><code>-- Create a small-world network\nselect src, dst\nfrom onager_gen_watts_strogatz(100, 4, 0.3, seed := 42);\n</code></pre> <p>Compare clustering at different rewiring probabilities:</p> <pre><code>-- Low beta: high clustering, long paths\nselect round(avg_clustering, 3) as clustering\nfrom onager_mtr_avg_clustering((select src, dst\n                                from onager_gen_watts_strogatz(50, 4, 0.1, seed := 42)));\n\n-- High beta: lower clustering, shorter paths\nselect round(avg_clustering, 3) as clustering\nfrom onager_mtr_avg_clustering((select src, dst\n                                from onager_gen_watts_strogatz(50, 4, 0.9, seed := 42)));\n</code></pre>"},{"location":"guide/generators/#complete-example-comparing-network-models","title":"Complete Example: Comparing Network Models","text":"<p>Generate and analyze different network types:</p> <pre><code>-- Create tables for each type\ncreate table random_net as\nselect src, dst\nfrom onager_gen_erdos_renyi(100, 0.05, seed := 42);\n\ncreate table scalefree_net as\nselect src, dst\nfrom onager_gen_barabasi_albert(100, 2, seed := 42);\n\ncreate table smallworld_net as\nselect src, dst\nfrom onager_gen_watts_strogatz(100, 4, 0.3, seed := 42);\n\n-- Compare structural properties\nselect 'Random'                                                                                     as model,\n       (select count(*) from random_net)                                                            as edges,\n       (select round(avg_clustering, 3) from onager_mtr_avg_clustering((select * from random_net))) as clustering,\n       (select diameter from onager_mtr_diameter((select * from random_net)))                       as diameter\nunion all\nselect 'Scale-free',\n       (select count(*) from scalefree_net),\n       (select round(avg_clustering, 3) from onager_mtr_avg_clustering((select * from scalefree_net))),\n       (select diameter from onager_mtr_diameter((select * from scalefree_net)))\nunion all\nselect 'Small-world',\n       (select count(*) from smallworld_net),\n       (select round(avg_clustering, 3) from onager_mtr_avg_clustering((select * from smallworld_net))),\n       (select diameter from onager_mtr_diameter((select * from smallworld_net)));\n</code></pre>"},{"location":"guide/graph-registry/","title":"Graph Registry","text":"<p>Onager provides an in-memory graph registry that stores named graphs for efficient repeated queries.</p>"},{"location":"guide/graph-registry/#when-to-use-the-registry","title":"When to Use the Registry","text":"<ul> <li>When querying the same graph multiple times</li> <li>When querying node or graph statistics</li> <li>When you want to run different queries or algorithms on the same graph</li> </ul>"},{"location":"guide/graph-registry/#creating-graphs","title":"Creating Graphs","text":"<pre><code>-- Create a directed graph\nselect onager_create_graph('social', true);\n\n-- Create an undirected graph\nselect onager_create_graph('network', false);\n</code></pre>"},{"location":"guide/graph-registry/#adding-data","title":"Adding Data","text":"<pre><code>-- Add nodes\nselect onager_add_node('social', 1);\nselect onager_add_node('social', 2);\nselect onager_add_node('social', 3);\n\n-- Add edges (with weights)\nselect onager_add_edge('social', 1, 2, 1.0);\nselect onager_add_edge('social', 1, 3, 0.5);\nselect onager_add_edge('social', 2, 3, 1.0);\n</code></pre>"},{"location":"guide/graph-registry/#querying-graphs","title":"Querying Graphs","text":"<pre><code>-- Get graph statistics\nselect onager_node_count('social'); -- 3\nselect onager_edge_count('social');\n-- 3\n\n-- Query node degrees\nselect onager_node_in_degree('social', 3); -- 2 (from nodes 1 and 2)\nselect onager_node_out_degree('social', 1); -- 2 (to nodes 2 and 3)\n</code></pre>"},{"location":"guide/graph-registry/#managing-graphs","title":"Managing Graphs","text":"<pre><code>-- List all graphs\nselect onager_list_graphs();\n-- '[\"social\", \"network\"]'\n\n-- Delete a graph\nselect onager_drop_graph('social');\n</code></pre>"},{"location":"guide/graph-registry/#graph-registry-vs-table-functions","title":"Graph Registry vs Table Functions","text":"Feature Graph Registry Table Functions Data storage In-memory Per-query Query type Scalar (single values) Table (result sets) Best for Point queries, repeated access One-time analysis Example <code>onager_node_in_degree('g', 1)</code> <code>onager_ctr_pagerank(edges)</code>"},{"location":"guide/graph-registry/#example-social-network-analysis","title":"Example: Social Network Analysis","text":"<pre><code>-- Setup\nselect onager_create_graph('friends', true);\n\n-- Bulk load from table\nselect onager_add_node('friends', user_id)\nfrom users;\nselect onager_add_edge('friends', follower_id, followed_id, 1.0)\nfrom follows;\n\n-- Query influential users (high out-degree)\nselect user_id, onager_node_out_degree('friends', user_id) as followers\nfrom users\norder by followers desc limit 10;\n\n-- Cleanup\nselect onager_drop_graph('friends');\n</code></pre>"},{"location":"guide/links/","title":"Link Prediction","text":"<p>Link prediction algorithms estimate the likelihood of edges that don't currently exist. These are useful for recommender systems, predicting future connections, or finding missing links in incomplete data.</p> <p>Performance</p> <p>Link prediction functions compute scores for all node pairs. That can produce O(n\u00b2) rows in the result set. So, it's recommended to use them only on smaller graphs (like with fewer than 1,000 nodes) and filter the results aggressively.</p>"},{"location":"guide/links/#setup","title":"Setup","text":"<pre><code>create table edges as\nselect *\nfrom (values (1::bigint, 2::bigint),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 4),\n             (4, 5)) t(src, dst);\n</code></pre>"},{"location":"guide/links/#jaccard-coefficient","title":"Jaccard Coefficient","text":"<p>The ratio of common neighbors to total neighbors of two nodes. Higher values indicate nodes are more similar and more likely to connect.</p> \\[ Jaccard(u, v) = \\frac{|N(u) \\cap N(v)|}{|N(u) \\cup N(v)|} \\] <pre><code>select node1, node2, round(jaccard, 4) as jaccard\nfrom onager_lnk_jaccard((select src, dst from edges))\nwhere jaccard &gt; 0\norder by jaccard desc limit 10;\n</code></pre> Column Type Description node1 bigint First node node2 bigint Second node jaccard double Jaccard similarity (0 to 1)"},{"location":"guide/links/#adamic-adar-index","title":"Adamic-Adar Index","text":"<p>Similar to common neighbors but gives more weight to rare neighbors. A common neighbor with few connections is more significant than one with many.</p> \\[ AA(u, v) = \\sum_{z \\in N(u) \\cap N(v)} \\frac{1}{\\log|N(z)|} \\] <pre><code>select node1, node2, round(score, 4) as adamic_adar\nfrom onager_lnk_adamic_adar((select src, dst from edges))\nwhere score &gt; 0\norder by score desc limit 10;\n</code></pre>"},{"location":"guide/links/#preferential-attachment","title":"Preferential Attachment","text":"<p>Based on the idea that nodes with many connections are likely to get more (the \"rich get richer\"). Simply the product of the degrees of two nodes.</p> \\[ PA(u, v) = |N(u)| \\times |N(v)| \\] <pre><code>select node1, node2, score as pref_attach\nfrom onager_lnk_pref_attach((select src, dst from edges))\norder by score desc limit 10;\n</code></pre>"},{"location":"guide/links/#resource-allocation","title":"Resource Allocation","text":"<p>Similar to Adamic-Adar but uses inverse degree instead of inverse log-degree. Models resource flow through common neighbors.</p> \\[ RA(u, v) = \\sum_{z \\in N(u) \\cap N(v)} \\frac{1}{|N(z)|} \\] <pre><code>select node1, node2, round(score, 4) as resource_alloc\nfrom onager_lnk_resource_alloc((select src, dst from edges))\nwhere score &gt; 0\norder by score desc limit 10;\n</code></pre>"},{"location":"guide/links/#complete-example-friend-recommendations","title":"Complete Example: Friend Recommendations","text":"<p>Find potential connections in a social network:</p> <pre><code>-- Sample social network\ncreate table friends as\nselect *\nfrom (values (1, 2),\n             (1, 3),\n             (1, 4),\n             (2, 3),\n             (2, 5),\n             (3, 4),\n             (3, 5),\n             (4, 6),\n             (5, 6),\n             (5, 7),\n             (6, 7),\n             (6, 8)) t(user_id, friend_id);\n\n-- Find non-connected pairs with high similarity\nwith existing as (select user_id as n1, friend_id as n2\n                  from friends\n                  union\n                  select friend_id, user_id\n                  from friends),\n     predictions as (select node1, node2, score\n                     from onager_lnk_adamic_adar((select user_id as src, friend_id as dst from friends))\n                     where score &gt; 0)\nselect p.node1 as user, p.node2 as suggested_friend, round(p.score, 3) as score\nfrom predictions p\n    left join existing e\non p.node1 = e.n1 and p.node2 = e.n2\nwhere e.n1 is null -- not already friends\n  and p.node1\n    &lt; p.node2      -- avoid duplicates\norder by p.score desc\n    limit 5;\n</code></pre>"},{"location":"guide/metrics/","title":"Graph Metrics","text":"<p>Graph metrics provide summary statistics about the overall structure of a network. These help understand properties like how tightly connected the graph is, how clustered it is, and how node degrees are distributed.</p>"},{"location":"guide/metrics/#setup","title":"Setup","text":"<pre><code>create table edges as\nselect *\nfrom (values (1::bigint, 2::bigint),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 4),\n             (3, 5),\n             (4, 5),\n             (5, 6)) t(src, dst);\n</code></pre>"},{"location":"guide/metrics/#diameter","title":"Diameter","text":"<p>The diameter is the longest shortest path between any two nodes. It measures how \"spread out\" the graph is. A small diameter means information can travel quickly across the network.</p> <pre><code>select diameter\nfrom onager_mtr_diameter((select src, dst from edges));\n</code></pre> Column Type Description diameter bigint Maximum shortest path in the graph"},{"location":"guide/metrics/#radius","title":"Radius","text":"<p>The radius is the minimum eccentricity of any node (the smallest maximum distance from any node to all other nodes). Nodes achieving the radius are called center nodes.</p> <pre><code>select radius\nfrom onager_mtr_radius((select src, dst from edges));\n</code></pre> Column Type Description radius bigint Minimum eccentricity in the graph"},{"location":"guide/metrics/#average-clustering-coefficient","title":"Average Clustering Coefficient","text":"<p>Measures how much nodes tend to cluster together. A clustering coefficient of 1.0 means every node's neighbors are all connected to each other (perfect cliques).</p> \\[ C_i = \\frac{2 \\cdot |\\{e_{jk}\\}|}{k_i(k_i - 1)} \\] <p>where \\(k_i\\) is the degree of node \\(i\\) and \\(|\\{e_{jk}\\}|\\) is the number of edges between its neighbors.</p> <pre><code>select round(avg_clustering, 4) as clustering\nfrom onager_mtr_avg_clustering((select src, dst from edges));\n</code></pre> Column Type Description avg_clustering double Average local clustering coefficient"},{"location":"guide/metrics/#transitivity","title":"Transitivity","text":"<p>Global clustering coefficient. The ratio of triangles to connected triples. Measures the overall tendency of the graph to form triangles.</p> \\[ T = \\frac{3 \\times \\text{triangles}}{\\text{connected triples}} \\] <pre><code>select round(transitivity, 4) as transitivity\nfrom onager_mtr_transitivity((select src, dst from edges));\n</code></pre> Column Type Description transitivity double Fraction of triangles to triples"},{"location":"guide/metrics/#triangle-count","title":"Triangle Count","text":"<p>Counts the number of triangles each node participates in. Triangles indicate strong local connectivity and are the basis for clustering coefficients.</p> <pre><code>select node_id, triangles\nfrom onager_mtr_triangles((select src, dst from edges))\nwhere triangles &gt; 0\norder by triangles desc;\n</code></pre> Column Type Description node_id bigint Node identifier triangles bigint Number of triangles containing node"},{"location":"guide/metrics/#assortativity","title":"Assortativity","text":"<p>Degree assortativity measures whether nodes tend to connect to nodes with similar degree. Positive values mean high-degree nodes connect to other high-degree nodes (assortative). Negative values mean high-degree nodes connect to low-degree nodes (disassortative).</p> <pre><code>select round(assortativity, 4) as assortativity\nfrom onager_mtr_assortativity((select src, dst from edges));\n</code></pre> Column Type Description assortativity double Degree correlation coefficient"},{"location":"guide/metrics/#average-path-length","title":"Average Path Length","text":"<p>The average shortest path distance between all pairs of reachable nodes. Lower values indicate a more tightly connected network where information can spread quickly.</p> <pre><code>select round(avg_path_length, 4) as avg_path\nfrom onager_mtr_avg_path_length((select src, dst from edges));\n</code></pre> Column Type Description avg_path_length double Mean shortest path across all pairs"},{"location":"guide/metrics/#graph-density","title":"Graph Density","text":"<p>The fraction of possible edges that actually exist. A density of 1.0 means a complete graph (all possible edges exist), while 0.0 means no edges.</p> <pre><code>select round(density, 4) as density\nfrom onager_mtr_density((select src, dst from edges));\n\n-- For directed graphs\nselect round(density, 4) as density\nfrom onager_mtr_density((select src, dst from edges), directed := true);\n</code></pre> Column Type Description density double Graph density (0.0 to 1.0) <p>Optional parameters:</p> <ul> <li><code>directed</code> (default false): Treat graph as directed</li> </ul>"},{"location":"guide/metrics/#complete-example-network-health-report","title":"Complete Example: Network Health Report","text":"<p>Generate a comprehensive report of network properties:</p> <pre><code>create table network as\nselect *\nfrom (values (1, 2),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 4),\n             (3, 5),\n             (4, 5),\n             (4, 6),\n             (5, 6),\n             (6, 7),\n             (7, 8),\n             (8, 9)) t(src, dst);\n\n-- All metrics in one query\nselect (select diameter from onager_mtr_diameter((select src, dst from network)))                       as diameter,\n       (select radius from onager_mtr_radius((select src, dst from network)))                           as radius,\n       (select round(avg_clustering, 3) from onager_mtr_avg_clustering((select src, dst from network))) as clustering,\n       (select round(transitivity, 3) from onager_mtr_transitivity((select src, dst from network)))     as transitivity,\n       (select round(assortativity, 3)\n        from onager_mtr_assortativity((select src, dst from network)))                                  as assortativity;\n\n-- Find the most clustered nodes\nselect node_id, triangles\nfrom onager_mtr_triangles((select src, dst from network))\norder by triangles desc limit 5;\n</code></pre>"},{"location":"guide/mst/","title":"Minimum Spanning Tree","text":"<p>Minimum Spanning Tree (MST) algorithms find a tree that connects all nodes with minimum total edge weight.</p>"},{"location":"guide/mst/#setup","title":"Setup","text":"<pre><code>-- Create weighted edges\ncreate table weighted_edges as select * from (values\n  (1::bigint, 2::bigint, 1.0::double),\n  (1, 3, 3.0), (2, 3, 2.0), (2, 4, 4.0), (3, 4, 5.0)\n) t(src, dst, weight);\n</code></pre>"},{"location":"guide/mst/#kruskals-algorithm","title":"Kruskal's Algorithm","text":"<p>Classic MST algorithm that sorts edges and greedily adds the smallest ones.</p> <pre><code>select src, dst, weight\nfrom onager_mst_kruskal((select src, dst, weight from weighted_edges))\norder by weight;\n</code></pre> Column Type Description src bigint Source node dst bigint Destination node weight double Edge weight"},{"location":"guide/mst/#prims-algorithm","title":"Prim's Algorithm","text":"<p>MST algorithm that grows the tree from a starting node.</p> <pre><code>select src, dst, weight\nfrom onager_mst_prim((select src, dst, weight from weighted_edges))\norder by weight;\n</code></pre> Column Type Description src bigint Source node dst bigint Destination node weight double Edge weight"},{"location":"guide/parallel/","title":"Parallel Algorithms","text":"<p>Parallel algorithms use multiple threads to process large graphs faster. These are optimized versions of common algorithms designed for better performance on multi-core systems.</p>"},{"location":"guide/parallel/#setup","title":"Setup","text":"<pre><code>create table edges as\nselect *\nfrom (values (1::bigint, 2::bigint),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 4),\n             (4, 5),\n             (4, 6),\n             (5, 6),\n             (5, 7),\n             (6, 7),\n             (7, 8)) t(src, dst);\n</code></pre>"},{"location":"guide/parallel/#parallel-pagerank","title":"Parallel PageRank","text":"<p>Computes PageRank centrality using parallel processing. Same semantics as the sequential version but faster on large graphs.</p> <pre><code>select node_id, round(rank, 4) as rank\nfrom onager_par_pagerank((select src, dst from edges))\norder by rank desc;\n</code></pre> Column Type Description node_id bigint Node identifier rank double PageRank score <p>Optional parameters:</p> <ul> <li><code>damping</code> (default 0.85): Probability of following a link</li> <li><code>iterations</code> (default 100): Maximum iterations</li> <li><code>directed</code> (default false): Treat graph as directed</li> </ul>"},{"location":"guide/parallel/#parallel-bfs","title":"Parallel BFS","text":"<p>Breadth-first search using parallel execution. Returns nodes in BFS order from the source.</p> <pre><code>select node_id\nfrom onager_par_bfs((select src, dst from edges), source := 1);\n</code></pre> Column Type Description node_id bigint Node visited during BFS"},{"location":"guide/parallel/#parallel-shortest-paths","title":"Parallel Shortest Paths","text":"<p>Computes shortest path distances from a source to all reachable nodes using parallel processing.</p> <pre><code>select node_id, distance\nfrom onager_par_shortest_paths((select src, dst from edges), source := 1)\norder by distance;\n</code></pre> Column Type Description node_id bigint Node identifier distance double Shortest distance from source"},{"location":"guide/parallel/#parallel-connected-components","title":"Parallel Connected Components","text":"<p>Finds connected components using a parallel union-find algorithm.</p> <pre><code>select node_id, component\nfrom onager_par_components((select src, dst from edges))\norder by component, node_id;\n</code></pre> Column Type Description node_id bigint Node identifier component bigint Component ID"},{"location":"guide/parallel/#parallel-clustering-coefficients","title":"Parallel Clustering Coefficients","text":"<p>Computes local clustering coefficient for each node using parallel processing.</p> <pre><code>select node_id, round(coefficient, 4) as clustering\nfrom onager_par_clustering((select src, dst from edges))\nwhere coefficient &gt; 0\norder by coefficient desc;\n</code></pre> Column Type Description node_id bigint Node identifier coefficient double Local clustering coefficient"},{"location":"guide/parallel/#parallel-triangle-count","title":"Parallel Triangle Count","text":"<p>Counts triangles participating at each node using parallel processing.</p> <pre><code>select node_id, triangles\nfrom onager_par_triangles((select src, dst from edges))\nwhere triangles &gt; 0\norder by triangles desc;\n</code></pre> Column Type Description node_id bigint Node identifier triangles bigint Number of triangles at node"},{"location":"guide/parallel/#complete-example-large-graph-analysis","title":"Complete Example: Large Graph Analysis","text":"<p>Use parallel algorithms for analyzing larger networks:</p> <pre><code>-- Generate a larger test graph\ncreate table large_net as\nselect src, dst\nfrom onager_gen_barabasi_albert(1000, 3, seed := 42);\n\n-- Parallel analysis pipeline\nselect 'Edges' as metric, count(*) ::varchar as value\nfrom large_net\nunion all\nselect 'Components', count(distinct component) ::varchar\nfrom onager_par_components((select src, dst from large_net))\nunion all\nselect 'Avg Clustering', round(avg(coefficient), 4) ::varchar\nfrom onager_par_clustering((select src, dst from large_net))\nunion all\nselect 'Total Triangles', (sum(triangles) / 3) ::varchar\nfrom onager_par_triangles((select src, dst from large_net));\n\n-- Find top nodes by parallel PageRank\nselect node_id, round(rank, 6) as rank\nfrom onager_par_pagerank((select src, dst from large_net))\norder by rank desc limit 10;\n</code></pre>"},{"location":"guide/parallel/#when-to-use-parallel-algorithms","title":"When to Use Parallel Algorithms","text":"<p>Parallel algorithms provide benefits for:</p> <ul> <li>Graphs with thousands of nodes or more</li> <li>Analysis pipelines running multiple algorithms</li> <li>Batch processing of multiple graphs</li> </ul> <p>For small graphs (under 1000 nodes), sequential algorithms may be faster due to parallelization overhead.</p>"},{"location":"guide/subgraphs/","title":"Subgraph Operations","text":"<p>Subgraph operations extract portions of a larger graph based on structural proximity or node membership. Useful for analyzing local neighborhoods or focusing on specific regions.</p>"},{"location":"guide/subgraphs/#setup","title":"Setup","text":"<pre><code>create table edges as\nselect *\nfrom (values (1::bigint, 2::bigint),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 4),\n             (4, 5),\n             (4, 6),\n             (5, 6),\n             (5, 7),\n             (6, 7),\n             (7, 8),\n             (8, 9)) t(src, dst);\n</code></pre>"},{"location":"guide/subgraphs/#ego-graph","title":"Ego Graph","text":"<p>Extracts the subgraph within a given radius of a center node. The ego graph includes the center node, all nodes within the specified number of hops, and all edges between them.</p> <pre><code>select src, dst\nfrom onager_sub_ego_graph((select src, dst from edges), center := 4, radius := 2);\n</code></pre> Column Type Description src bigint Source node of edge dst bigint Destination node <p>Parameters:</p> <ul> <li><code>center</code>: The central node of the ego graph</li> <li><code>radius</code>: Maximum distance from center (number of hops)</li> </ul> <pre><code>-- Compare ego graphs at different radii\nselect 'radius=1' as scope, count(*) as edges\nfrom onager_sub_ego_graph((select src, dst from edges), center := 4, radius := 1)\nunion all\nselect 'radius=2', count(*)\nfrom onager_sub_ego_graph((select src, dst from edges), center := 4, radius := 2)\nunion all\nselect 'radius=3', count(*)\nfrom onager_sub_ego_graph((select src, dst from edges), center := 4, radius := 3);\n</code></pre>"},{"location":"guide/subgraphs/#k-hop-neighbors","title":"K-Hop Neighbors","text":"<p>Returns all nodes within k hops of a starting node. Unlike ego graph, this returns only node IDs, not edges.</p> <pre><code>select node_id\nfrom onager_sub_k_hop((select src, dst from edges), start := 1, k := 2)\norder by node_id;\n</code></pre> Column Type Description node_id bigint Node within k hops of start node <p>Parameters:</p> <ul> <li><code>start</code>: Starting node</li> <li><code>k</code>: Maximum number of hops (0 returns just the start node)</li> </ul> <pre><code>-- Find nodes at exactly distance 2 (in 2-hop but not in 1-hop)\nwith hop1 as (select node_id from onager_sub_k_hop((select src, dst from edges), start := 1, k := 1)),\n     hop2 as (select node_id from onager_sub_k_hop((select src, dst from edges), start := 1, k := 2))\nselect h2.node_id\nfrom hop2 h2\n         left join hop1 h1 on h2.node_id = h1.node_id\nwhere h1.node_id is null;\n</code></pre>"},{"location":"guide/subgraphs/#induced-subgraph","title":"Induced Subgraph","text":"<p>Given a set of nodes, returns the subgraph containing only those nodes and the edges between them. The induced subgraph preserves the original graph structure within the specified node set.</p> <pre><code>-- Extract subgraph for specific nodes using array syntax\nselect src, dst\nfrom onager_sub_induced((select src, dst from edges), nodes := [2, 3, 4, 5]);\n</code></pre> Column Type Description src bigint Source node of edge dst bigint Destination node <p>[!NOTE] DuckDB table functions support only one subquery parameter, so use the array syntax shown above.</p>"},{"location":"guide/subgraphs/#complete-example-neighborhood-analysis","title":"Complete Example: Neighborhood Analysis","text":"<p>Analyze the local structure around a node of interest:</p> <pre><code>create table social as\nselect *\nfrom (values (1, 2),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 4),\n             (3, 5),\n             (4, 5),\n             (4, 6),\n             (5, 6),\n             (5, 7),\n             (6, 7),\n             (6, 8),\n             (7, 8),\n             (7, 9),\n             (8, 9),\n             (8, 10)) t(src, dst);\n\n-- Find nodes near user 5\nselect node_id as nearby_user\nfrom onager_sub_k_hop((select src, dst from social), start := 5, k := 2)\norder by node_id;\n\n-- Get the ego network and analyze it\nwith ego as (select src, dst\n             from onager_sub_ego_graph((select src, dst from social), center := 5, radius := 2))\nselect (select count(distinct src) + count(distinct dst) from (select src from ego union select dst from ego)) as nodes,\n       (select count(*) from ego)                                                                              as edges,\n       (select round(avg_clustering, 3)\n        from onager_mtr_avg_clustering((select * from ego)))                                                   as clustering;\n\n-- Compute centrality within the neighborhood\nwith ego as (select src, dst\n             from onager_sub_ego_graph((select src, dst from social), center := 5, radius := 2))\nselect node_id, round(rank, 4) as local_importance\nfrom onager_ctr_pagerank((select * from ego))\norder by rank desc limit 5;\n</code></pre>"},{"location":"guide/traversal/","title":"Traversal and Paths","text":"<p>Traversal algorithms systematically visit nodes in a graph. Shortest path algorithms find optimal routes between nodes. These are fundamental operations for graph analysis.</p>"},{"location":"guide/traversal/#setup","title":"Setup","text":"<pre><code>create table edges as\nselect *\nfrom (values (1::bigint, 2::bigint),\n             (1, 3),\n             (2, 4),\n             (3, 4),\n             (4, 5),\n             (4, 6),\n             (5, 7),\n             (6, 7),\n             (7, 8)) t(src, dst);\n</code></pre>"},{"location":"guide/traversal/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":"<p>Explores nodes level by level, starting from a source. Visits all neighbors before moving to neighbors of neighbors. Useful for finding shortest paths in unweighted graphs.</p> <pre><code>select node_id, order_num\nfrom onager_trv_bfs((select src, dst from edges), source := 1)\norder by order_num;\n</code></pre> Column Type Description node_id bigint Node identifier order_num bigint Order in which node was visited (0-based)"},{"location":"guide/traversal/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":"<p>Explores as far as possible along each branch before backtracking. Visits a neighbor, then that neighbor's neighbor, and so on. Useful for topological sorting and cycle detection.</p> <pre><code>select node_id, order_num\nfrom onager_trv_dfs((select src, dst from edges), source := 1)\norder by order_num;\n</code></pre>"},{"location":"guide/traversal/#dijkstras-algorithm","title":"Dijkstra's Algorithm","text":"<p>Finds shortest paths from a source to all reachable nodes. Assumes non-negative edge weights. The classic algorithm for shortest paths.</p> <pre><code>select node_id, distance\nfrom onager_pth_dijkstra((select src, dst from edges), source := 1)\norder by distance;\n</code></pre> Column Type Description node_id bigint Node identifier distance double Shortest distance from source"},{"location":"guide/traversal/#bellman-ford-algorithm","title":"Bellman-Ford Algorithm","text":"<p>Finds shortest paths even with negative edge weights. Slower than Dijkstra but more general. Can detect negative cycles.</p> <p>For weighted edges, provide a third column:</p> <pre><code>create table weighted_edges as\nselect *\nfrom (values (1::bigint, 2::bigint, 1.0),\n             (1, 3, 4.0),\n             (2, 3, 2.0),\n             (2, 4, 5.0),\n             (3, 4, 1.0)) t(src, dst, weight);\n\nselect node_id, distance\nfrom onager_pth_bellman_ford((select src, dst, weight from weighted_edges), source := 1)\norder by distance;\n</code></pre>"},{"location":"guide/traversal/#floyd-warshall-algorithm","title":"Floyd-Warshall Algorithm","text":"<p>Computes shortest paths between all pairs of nodes. Returns a row for every (source, destination) pair. Useful when you need distances between many node pairs.</p> <p>Performance</p> <p>This algorithm has O(n\u00b3) time and O(n\u00b2) space complexity. So, it's recommended to use it only on smaller graphs (like with fewer than 1,000 nodes).</p> <pre><code>select src, dst, round(distance, 2) as distance\nfrom onager_pth_floyd_warshall((select src, dst, 1.0 as weight from edges))\nwhere distance &lt; 1000\norder by src, dst;\n</code></pre> Column Type Description src bigint Source node dst bigint Destination node distance double Shortest distance between them"},{"location":"guide/traversal/#complete-example-network-distance-analysis","title":"Complete Example: Network Distance Analysis","text":"<p>Find the most central nodes by shortest path distances:</p> <pre><code>create table network as\nselect *\nfrom (values (1, 2),\n             (1, 3),\n             (2, 3),\n             (2, 4),\n             (3, 5),\n             (4, 5),\n             (4, 6),\n             (5, 6),\n             (5, 7),\n             (6, 7),\n             (7, 8)) t(src, dst);\n\n-- Find nodes closest to node 1\nselect node_id, distance\nfrom onager_pth_dijkstra((select src, dst from network), source := 1)\norder by distance limit 5;\n\n-- Compare BFS order vs distance\nwith bfs as (select node_id, order_num from onager_trv_bfs((select src, dst from network), source := 1)),\n     dist as (select node_id, distance from onager_pth_dijkstra((select src, dst from network), source := 1))\nselect bfs.node_id, bfs.order_num as visit_order, dist.distance\nfrom bfs\n         join dist on bfs.node_id = dist.node_id\norder by bfs.order_num;\n</code></pre>"},{"location":"reference/input-formats/","title":"Input Formats","text":"<p>This page describes how to pass graph data to Onager functions.</p>"},{"location":"reference/input-formats/#table-functions","title":"Table Functions","text":"<p>Table functions expect edges as a subquery with two <code>bigint</code> columns:</p> <pre><code>select *\nfrom onager_ctr_pagerank((select src, dst from my_edges));\n</code></pre>"},{"location":"reference/input-formats/#named-graphs","title":"Named Graphs","text":"<p>Scalar functions operate on named graphs stored in the registry:</p> <pre><code>select onager_create_graph('social', true);\nselect onager_add_node('social', 1);\nselect onager_node_in_degree('social', 1);\n</code></pre> <p>Edge list format</p> <p>Onager uses edge lists, not adjacency matrices. Each row represents one edge with a source and destination node.</p> <p>Node IDs</p> <p>Node IDs must be <code>bigint</code> integers. They do not need to be continuous or start from zero. Any integer value works, like <code>1, 2, 3</code> or <code>100, 200, 500</code>.</p> <p>Directed vs undirected</p> <p>Most functions treat graphs as undirected by default. Use the <code>directed := true</code> parameter where available to treat edges as one-way.</p> <p>Weighted functions</p> <p>Some functions accept edge weights as a third column. These include:</p> <ul> <li><code>onager_pth_bellman_ford</code> \u2014 shortest paths with negative weights</li> <li><code>onager_pth_floyd_warshall</code> \u2014 all-pairs shortest paths</li> <li><code>onager_mst_kruskal</code> \u2014 minimum spanning tree</li> <li><code>onager_mst_prim</code> \u2014 minimum spanning tree</li> <li><code>onager_apx_tsp</code> \u2014 traveling salesman approximation</li> </ul> <p>Pass weights like this: <pre><code>select * from onager_mst_kruskal((select src, dst, weight from edges));\n</code></pre></p>"},{"location":"reference/sql-functions/","title":"SQL Function Reference","text":"<p>Complete reference for all Onager SQL functions.</p>"},{"location":"reference/sql-functions/#graph-management-functions","title":"Graph Management Functions","text":"Function Returns Description <code>onager_create_graph(name, directed)</code> <code>integer</code> Create a named graph (0=success) <code>onager_drop_graph(name)</code> <code>integer</code> Delete a named graph <code>onager_add_node(graph, node_id)</code> <code>integer</code> Add a node to graph <code>onager_add_edge(graph, src, dst, weight)</code> <code>integer</code> Add a weighted edge <code>onager_list_graphs()</code> <code>varchar</code> List all graphs (JSON array) <code>onager_node_count(graph)</code> <code>bigint</code> Count nodes in graph <code>onager_edge_count(graph)</code> <code>bigint</code> Count edges in graph"},{"location":"reference/sql-functions/#scalar-query-functions","title":"Scalar Query Functions","text":"Function Returns Description <code>onager_node_in_degree(graph, node)</code> <code>bigint</code> In-degree of a node <code>onager_node_out_degree(graph, node)</code> <code>bigint</code> Out-degree of a node"},{"location":"reference/sql-functions/#centrality-functions","title":"Centrality Functions","text":"Function Returns Description <code>onager_ctr_pagerank(edges)</code> <code>node_id, rank</code> PageRank centrality <code>onager_ctr_degree(edges)</code> <code>node_id, in_degree, out_degree</code> Degree centrality <code>onager_ctr_betweenness(edges)</code> <code>node_id, betweenness</code> Betweenness centrality <code>onager_ctr_closeness(edges)</code> <code>node_id, closeness</code> Closeness centrality <code>onager_ctr_eigenvector(edges)</code> <code>node_id, eigenvector</code> Eigenvector centrality <code>onager_ctr_katz(edges, alpha)</code> <code>node_id, katz</code> Katz centrality <code>onager_ctr_harmonic(edges)</code> <code>node_id, harmonic</code> Harmonic centrality <code>onager_ctr_personalized_pagerank(...)</code> <code>node_id, rank</code> Personalized PageRank <code>onager_ctr_voterank(edges, num_seeds)</code> <code>node_id</code> VoteRank influential spreaders <code>onager_ctr_local_reaching(edges, distance)</code> <code>node_id, centrality</code> Local reaching centrality <code>onager_ctr_laplacian(edges)</code> <code>node_id, centrality</code> Laplacian centrality"},{"location":"reference/sql-functions/#community-detection-functions","title":"Community Detection Functions","text":"Function Returns Description <code>onager_cmm_louvain(edges [, seed])</code> <code>node_id, community</code> Louvain modularity optimization <code>onager_cmm_components(edges)</code> <code>node_id, component</code> Connected components <code>onager_cmm_label_prop(edges)</code> <code>node_id, label</code> Label propagation <code>onager_cmm_girvan_newman(edges, communities)</code> <code>node_id, community</code> Girvan-Newman edge betweenness <code>onager_cmm_spectral(edges, k)</code> <code>node_id, cluster</code> Spectral clustering <code>onager_cmm_infomap(edges)</code> <code>node_id, community</code> Infomap community detection"},{"location":"reference/sql-functions/#link-prediction-functions","title":"Link Prediction Functions","text":"Function Returns Description <code>onager_lnk_jaccard(edges)</code> <code>node1, node2, jaccard</code> Jaccard coefficient <code>onager_lnk_adamic_adar(edges)</code> <code>node1, node2, score</code> Adamic-Adar index <code>onager_lnk_pref_attach(edges)</code> <code>node1, node2, score</code> Preferential attachment <code>onager_lnk_resource_alloc(edges)</code> <code>node1, node2, score</code> Resource allocation <code>onager_lnk_common_neighbors(edges)</code> <code>node1, node2, count</code> Common neighbors count"},{"location":"reference/sql-functions/#metric-functions","title":"Metric Functions","text":"Function Returns Description <code>onager_mtr_diameter(edges)</code> <code>diameter</code> Graph diameter <code>onager_mtr_radius(edges)</code> <code>radius</code> Graph radius <code>onager_mtr_avg_clustering(edges)</code> <code>avg_clustering</code> Average clustering coefficient <code>onager_mtr_avg_path_length(edges)</code> <code>avg_path_length</code> Average shortest path length <code>onager_mtr_transitivity(edges)</code> <code>transitivity</code> Global clustering (transitivity) <code>onager_mtr_triangles(edges)</code> <code>node_id, triangles</code> Triangle count per node <code>onager_mtr_assortativity(edges)</code> <code>assortativity</code> Degree assortativity coefficient <code>onager_mtr_density(edges)</code> <code>density</code> Graph density (0 to 1)"},{"location":"reference/sql-functions/#path-and-traversal-functions","title":"Path and Traversal Functions","text":"Function Returns Description <code>onager_pth_dijkstra(edges, source)</code> <code>node_id, distance</code> Shortest paths from source <code>onager_pth_bellman_ford(weighted_edges, source)</code> <code>node_id, distance</code> Shortest paths (negative weights) <code>onager_pth_floyd_warshall(weighted_edges)</code> <code>src, dst, distance</code> All-pairs shortest paths <code>onager_trv_bfs(edges, source)</code> <code>node_id, order</code> Breadth-first traversal <code>onager_trv_dfs(edges, source)</code> <code>node_id, order</code> Depth-first traversal"},{"location":"reference/sql-functions/#approximation-functions","title":"Approximation Functions","text":"Function Returns Description <code>onager_apx_max_clique(edges)</code> <code>node_id</code> Maximum clique (approximation) <code>onager_apx_independent_set(edges)</code> <code>node_id</code> Maximum independent set (approx) <code>onager_apx_vertex_cover(edges)</code> <code>node_id</code> Minimum vertex cover (approx) <code>onager_apx_tsp(weighted_edges)</code> <code>order, node_id</code> TSP tour (greedy approx)"},{"location":"reference/sql-functions/#minimum-spanning-tree","title":"Minimum Spanning Tree","text":"Function Returns Description <code>onager_mst_kruskal(weighted_edges)</code> <code>src, dst, weight</code> Kruskal's MST"},{"location":"reference/sql-functions/#generator-functions","title":"Generator Functions","text":"Function Returns Description <code>onager_gen_erdos_renyi(n, p [, seed])</code> <code>src, dst</code> Random graph (G(n,p)) <code>onager_gen_barabasi_albert(n, m [, seed])</code> <code>src, dst</code> Scale-free graph <code>onager_gen_watts_strogatz(n, k, beta [, seed])</code> <code>src, dst</code> Small-world graph"},{"location":"reference/sql-functions/#subgraph-operations","title":"Subgraph Operations","text":"Function Returns Description <code>onager_sub_ego_graph(edges, center, radius)</code> <code>src, dst</code> Ego graph around a node <code>onager_sub_k_hop(edges, start, k)</code> <code>node_id</code> Nodes within k hops <code>onager_sub_induced(edges, nodes)</code> <code>src, dst</code> Induced subgraph"},{"location":"reference/sql-functions/#parallel-algorithms","title":"Parallel Algorithms","text":"Function Returns Description <code>onager_par_pagerank(edges)</code> <code>node_id, rank</code> Parallel PageRank <code>onager_par_bfs(edges, source)</code> <code>node_id</code> Parallel BFS traversal <code>onager_par_shortest_paths(edges, source)</code> <code>node_id, distance</code> Parallel shortest paths <code>onager_par_components(edges)</code> <code>node_id, component</code> Parallel connected components <code>onager_par_clustering(edges)</code> <code>node_id, coefficient</code> Parallel clustering coefficients <code>onager_par_triangles(edges)</code> <code>node_id, triangles</code> Parallel triangle count"},{"location":"reference/sql-functions/#utility-functions","title":"Utility Functions","text":"Function Returns Description <code>onager_version()</code> <code>varchar</code> Extension version <code>onager_last_error()</code> <code>varchar</code> Last error message <p>See Input Formats for details on how to pass graph data to functions.</p>"}]}